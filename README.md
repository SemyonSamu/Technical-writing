# Technical-writing
<h1>Installing Helm 3<h1>
  
Installing helm 3 has no difference from helm 2. It's still the same statically linked binary. It is enough just to download it and pass it in the $PATH or create a symbolic link in /usr/bin. For Ansible users was created a role that automates this process.


<h1>Tiller removal<h1>
  
You probably already know that helm 3 is tiller less. Indeed tiller is permanently and irrevocably removed. Now helm uses the Kubernetes API, using your credentials, which is undoubtedly more secure, but is it so convenient?

On the one hand, yes - you no longer need to do the tedious helm init, and then poke around in Kubernetes RBAC for 3 hours, because nothing works. Plus, there is less load, especially if you use the one namespace - one tiller strategy.

On the other hand, helm is now namespaced out of the box. This means two things: first, the namespace in Kubernetes must exist before you start deploying anything. How exactly you decide this helm is not interested - you can no longer create namespaces using helm. Second, do chart listing, updates, etc. it is necessary to specify --namespace, since helm now stores the release state in the same namespace, and not as it was before in kube-system. It means that the load on the fingers increased a little)

It is also worth mentioning that now the default repository for releases is Kubernetes Secrets, not ConfigMap as it was in helm 2. You can still use ConfigMap if you want, but you will have to export the variable.
```
$export HELM_DRIVER=configmap
```
<h1>Three-sided patch<h1>
  
What's really nice is that helm v3 now takes manual changes after the chart was installed. It means that if someone manually changed some parameter, helm 2 will not scratch during the update, if it has not changed relative to the saved state. Helm 3 will check if what it is asked to do matches what is in reality and in state. And this is very cool.


<h1>Variable verification support<h1>
  
Helm 3 provides the ability to define a schema for variables to notify the user if they are doing something that the chart developer did not expect. For example, you can specify which variables must be defined, what data type must be at the bottom, etc. For example, if you put the file "values.schema.json" in the directory with the chart with the following content
```
{
  "$schema": "https://json-schema.org/draft-07/schema#",
  "title": "Values",
  "type": "object",
  "properties": {
    "image": {
      "type": "object",
      "description": "Container Image",
      "properties": {
        "name": { "type": "string" },
        "tag": { "type": "string" }
      }
    },
    "replicaCount": {
      "description": "Number Of replicas",
      "minimum": 1,
      "type": "integer"
    }
  },
  "required": [
    "replicaCount"
  ]
}
```

then during installation, if the user has not defined the "replicaCount" variable, an error message will be displayed.
```
Error: values don't meet the specifications of the schema(s) in the following chart(s):
nginx:
- (root): replicaCount is required
```

Of course, this function only works in helm v3, helm v2 simply ignores the schema.


<h1>Docker Registry support<h1>
  
Helm 3 now has support for the docker registry. What does it mean? This means that you no longer need to search for yourself a separate helm repository such as ChartMuseum. ChartMuseum was a good option for centralized storage of charts, but it also served as an additional layer in your infrastructure, requiring updates, monitoring, access control, etc. Helm repository support from services such as Nexus, AWS, etc. never made it to the masses. Now you can store charts directly in docker repositories. This works great with vanilla Docker Registry or GitLab Registry, for example. People say they also push to GCR with no problem.
How is it all done? First, you need to enable this feature explicitly, as it is still experimental in mid-2020. We do
```
export HELM_EXPERIMENTAL_OCI=1
```
Next, you need to log into your repository. Note that Helm does not use the configuration generated by the docker login command! Let's say you are using GitLab.
```
$ helm registry login registry.gitlab.com
Username: XXXX
Password: XXXX
Login succeeded
``` 
Next, create a package and push it to the helm repository. Building a package involves tagging, just like it does in the docker build process.
```
$ helm creat nginx
$ helm chart save \
nginx/  registry.gitlab.com/hippolab/helm-charts/nginx:0.0.1
$ helm chart push \
registry.gitlab.com/hippolab/helm-charts/nginx:0.0.1
The push refers to repository
ref:     registry.gitlab.com/hippolab/helm-charts/nginx:0.0.1
digest:  de77123c5fc63e0443bc0357aa25e7a0bfc725cb40
size:    9.1 KiB
name:    nxing
version: 0.0.1
``` 
Unfortunately, at the moment, helm install of such charts cannot be done directly, if you deploy from the pipeline, then you will first need to pull the chart, and then export
```
$ helm chart pull \
registry.gitlab.com/hippolab/helm-charts/nginx:0.0.1
$ helm chart export \
registry.gitlab.com/hippolab/helm-charts/nginx:0.0.1
``` 
After that, the "nginx" folder will appear in your current directory containing the nginx helm chart, which can already be deployed.

